{"version":3,"names":[],"mappings":"","sources":["scripts/app.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _wbxWordCloud = __webpack_require__(1);\n\n\tangular.module('wordCloud', ['wbxWordCloud']);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _wordService = __webpack_require__(2);\n\n\tvar _wbxWordCloudDirective = __webpack_require__(3);\n\n\t/**\n\t * Created by Harel on 24/07/2016.\n\t */\n\n\n\tangular.module('wbxWordCloud', []).service('wordService', _wordService.wordService).directive('wbxWordCloud', _wbxWordCloudDirective.wbxWordCloud);\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Created by Harel on 08/06/2016.\n\t */\n\n\tvar wordService = exports.wordService = function () {\n\t  wordService.$inject = [\"$q\", \"$http\"];\n\t  function wordService($q, $http) {\n\t    'ngInject';\n\n\t    _classCallCheck(this, wordService);\n\n\t    this.$q = $q;\n\n\t    this.http = $http;\n\n\t    this.selectionMode = '';\n\n\t    this.hoveredMode = '';\n\n\t    this.data = '';\n\n\t    this.fontMin = 12, this.fontMax = 32;\n\t  }\n\n\t  // get delimiters from config file\n\n\n\t  _createClass(wordService, [{\n\t    key: 'getConfig',\n\t    value: function getConfig(configPath, configParams) {\n\t      var defer = this.$q.defer();\n\t      if (angular.isUndefined(configParams)) {\n\t        configPath = angular.isDefined(configPath) ? configPath : this.getCurrentDirectory();\n\t        this.http.get(configPath + 'wbxCloudConfig.json').then(function (response) {\n\t          defer.resolve(response.data);\n\t        }, function (response) {\n\t          // Error callback\n\t          defer.resolve(\"Error\"); // Reject\n\t        });\n\t      } else {\n\t          return configParams;\n\t        }\n\n\t      return defer.promise;\n\t    }\n\t  }, {\n\t    key: 'setText',\n\t    value: function setText(data, append) {\n\n\t      function handleTextData(config) {\n\t        var parsedData = that.wordService.dataToWordsArr(config.delimiters, that.text); // get the delimiters\n\t        that.initCloud(parsedData);\n\t      }\n\n\t      // append data to this.text\n\t      if (append && this.text != null && this.text != \"\" && angular.isDefined(data)) {\n\t        this.text = this.text.concat(data);\n\t      } else {\n\t        this.text = data;\n\t      }\n\t      var that = this;\n\n\t      that.wordService.$q.when(that.wordService.getConfig(this.config.configUrl, this.config.configParams)).then(handleTextData);\n\t    }\n\t  }, {\n\t    key: 'setListener',\n\t    value: function setListener(eventName, callback) {\n\t      function unHookEvent() {\n\t        this.events.splice(this.index, 1);\n\t        this.events = null;\n\t        this.index = null;\n\t      }\n\n\t      if (angular.isUndefined(this.events)) {\n\t        this.events = {};\n\t      }\n\n\t      if (angular.isUndefined(this.events[eventName])) {\n\t        this.events[eventName] = [];\n\t      }\n\n\t      return unHookEvent.bind({ events: this.events[eventName], index: this.events[eventName].push(callback) - 1 });\n\t    }\n\n\t    // Bellow 2 function relate to API\n\n\t  }, {\n\t    key: 'onSelect',\n\t    value: function onSelect(allWords, selectedWordId) {\n\n\t      var that = this,\n\t          words = allWords,\n\t          theWord = words[selectedWordId].text;\n\n\t      if (window.event.ctrlKey) {\n\t        _.forEach(words, function (w) {\n\t          if (theWord === w.text) {\n\t            if (w.selected) d3.select('#p' + w.id).classed(\"selected\", true);else d3.select('#p' + w.id).classed(\"selected\", false);\n\t          } else {\n\t            var flag = theWord == w.text ? true : w.selected;\n\t            d3.select('#p' + w.id).classed(\"selected\", flag);\n\t          }\n\t        });\n\t      } else {\n\t        _.forEach(words, function (w) {\n\t          if (w.text == theWord && w.selected) {\n\t            d3.select('#p' + w.id).classed(\"selected\", true);\n\t            that.selectionMode = true;\n\t          } else {\n\t            d3.select('#p' + w.id).classed(\"selected\", false);\n\t          }\n\t        });\n\t      }\n\t      //Now if any word still selected apply the selection class even after deselect event\n\t      var selectionMode = [];\n\t      for (var i = 0; i < words.length; i++) {\n\t        if (words[i].selected) {\n\t          selectionMode.push(\"selected\");\n\t        }\n\t      }\n\t      d3.select(this.elem).classed(\"selection-mode\", selectionMode.length > 0);\n\t    }\n\t  }, {\n\t    key: 'onHover',\n\t    value: function onHover(allWords, hoveredWordId) {\n\t      // we want to hover/unhover the allWords[hoveredWordId]\n\t      //so to find full correlation and regardless the order in DOM we need to correlate between Id and Dom element\n\t      //\n\t      d3.select('#p' + hoveredWordId).classed(\"hovered\", allWords[hoveredWordId].hovered);\n\t      d3.select(this.elem).classed(\"hover-mode\", allWords[hoveredWordId].hovered);\n\t    }\n\t  }, {\n\t    key: 'runListeners',\n\t    value: function runListeners(eventName, data, arr) {\n\t      if (angular.isUndefined(this.events) || angular.isUndefined(this.events[eventName])) {\n\t        return;\n\t      }\n\n\t      _.forEach(this.events[eventName], function (event) {\n\t        event(data, arr);\n\t      });\n\t    }\n\n\t    /**\n\t     * @description parse the data:\n\t     *              1) Gets delimiters and parse it to regex\n\t     *              2) Use the regex delimiters to push each word into matchedWords array\n\t     *              3) For each word in matchedWords push it into stats array ,\n\t     *                and define the correspond id, size(frequency),\n\t     *                children (identical words in matchedWords by index).\n\t     *              4) Do wordService.data=stats and return stats\n\t     * @param delimiters\n\t     * @param newData\n\t     * @returns {Array}\n\t     */\n\n\t  }, {\n\t    key: 'setDelimiters',\n\t    value: function setDelimiters(delimiters) {\n\t      var t = \"\",\n\t          pattern;\n\t      if (angular.isDefined(delimiters)) {\n\t        for (var property in delimiters) {\n\t          if (delimiters.hasOwnProperty(property)) {\n\t            t += delimiters[property];\n\t          }\n\t        }\n\t        var x = '[]';\n\t        pattern = new RegExp(x.replace(\"[]\", \"[^\" + t + \"]+\"), \"g\");\n\t      } else pattern = 99; // 99 --> no delimiter , will be handle in setMatchWords()\n\n\t      return pattern;\n\t    }\n\t  }, {\n\t    key: 'setMatchWords',\n\t    value: function setMatchWords(text, pattern) {\n\t      this.matchedWords = [];\n\t      if (pattern = 99) {\n\t        //no delimiters - use all the delimiters to delimiter\n\t        pattern = /([A-Z]||[a-z])\\w+/g;\n\t      }\n\t      if (text.constructor.name == \"String\") {\n\t        this.matchedWords.push(text.match(pattern)); // takes each word from text and put them into elements in array\n\t      } else if (text.constructor.name == \"Array\") {\n\t          for (var i = 0; i < text.length; i++) {\n\t            this.matchedWords.push(text[i].toString().match(pattern)); // takes each word from text and put them into elements in array\n\t          }\n\t        }\n\t      return this.matchedWords;\n\t    }\n\t  }, {\n\t    key: 'setStats',\n\t    value: function setStats(matchedWords) {\n\t      var stats = [],\n\t          wordId = -1;\n\t      matchedWords.forEach(function (word, index) {\n\t        if (angular.isDefined(word) && word != null) {\n\t          word.forEach(function (elm) {\n\t            var obj = _.find(stats, { text: elm });\n\t            if (obj != undefined) {\n\t              //if word already exist, increase its size and push it occurrence in the array (children)\n\t              obj.size += 1;\n\t              obj.children.push(index);\n\t            } else {\n\t              // otherwise, push the word to array\n\t              stats.push({ text: elm, id: ++wordId, size: 1, children: [index] });\n\t            }\n\t          });\n\t        }\n\t      });\n\t      this.data = stats;\n\t      return this.data;\n\t    }\n\t  }, {\n\t    key: 'dataToWordsArr',\n\t    value: function dataToWordsArr(delimiters, newData) {\n\n\t      var pattern = this.setDelimiters(delimiters);\n\t      var matchedWords = this.setMatchWords(newData, pattern);\n\t      this.setStats(matchedWords);\n\n\t      return this.data; // this.data has : size = the number of occurrences in cloud, children : the indexes of the sentences where the word appears .\n\t    }\n\t  }, {\n\t    key: 'calcFontSize',\n\t    value: function calcFontSize(id) {\n\t      var arr = [];\n\n\t      for (var i = 0; i < this.data.length; i++) {\n\t        arr[i] = this.data[i].size;\n\t      }\n\t      this.maxTagged = Math.max.apply(Math, arr);\n\t      this.minTagged = Math.min.apply(Math, arr);\n\n\t      var size = this.data[id].children.length == this.minTagged ? this.fontMin : this.data[id].children.length / this.maxTagged * (this.fontMax - this.fontMin) + this.fontMin;\n\n\t      return size;\n\t    }\n\t  }, {\n\t    key: 'getRate',\n\t    value: function getRate(id) {\n\t      while (!isNaN(id)) {\n\t        return (this.data[id].children.length / this.maxTagged).toFixed(2);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getCurrentDirectory',\n\t    value: function getCurrentDirectory() {\n\t      //@@ Dev Version @@\n\t      /*  var scripts = document.getElementsByTagName(\"script\"), i;\n\t       for (i = 0; i < scripts.length; i++) {\n\t          if (scripts[i].src.search(/index.module.js/i) > 0) {\n\t            break;\n\t          }\n\t        }\n\t        var currentScriptPath = scripts[i].src;*/\n\t      // var resCurrentDirectory = currentScriptPath.substring(0, currentScriptPath.lastIndexOf(\"/app/\") + 1);\n\n\t      // Build Version :\n\t      var resCurrentDirectory = document.getElementsByTagName(\"script\")[0].baseURI;\n\t      return resCurrentDirectory;\n\t    }\n\t  }]);\n\n\t  return wordService;\n\t}();\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\texports.wbxWordCloud = wbxWordCloud;\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Created by Harel on 05/06/2016.\n\t */\n\tfunction wbxWordCloud() {\n\t  'ngInject';\n\n\t  var directive = {\n\t    templateUrl: 'app/components/wordCloud/wordCloud.html',\n\t    controller: WordCloudController,\n\t    controllerAs: 'vm',\n\t    scope: {\n\t      words: '=',\n\t      config: \"=wordCloudConfig\"\n\t    },\n\t    replace: true,\n\t    bindToController: true,\n\t    link: linkFunc\n\n\t  };\n\n\t  function linkFunc(scope, element, attr, ctrl) {\n\t    // element = div of the wordCloud\n\n\t    ctrl.onInit();\n\n\t    scope.$on(\"$destroy,\", function () {\n\t      ctrl.element = null;\n\t      console.log(\"wordCloud directive destroyed\");\n\t    });\n\t  }\n\n\t  return directive;\n\t}\n\n\tvar WordCloudController = function () {\n\t  WordCloudController.$inject = [\"wordService\", \"$element\"];\n\t  function WordCloudController(wordService, $element) {\n\t    'ngInject';\n\n\t    _classCallCheck(this, WordCloudController);\n\n\t    this.count = 0;\n\t    var that = this;\n\t    this.element = $element;\n\t    this.wordService = wordService;\n\t    this.runListeners = this.wordService.runListeners.bind(this);\n\t    this.onInit = function onInit() {\n\t      /* setup the API\n\t       The purpose of the next 10 lines is to set API to any external directive that want to adapt the cloud so it can use setText or setListener.\n\t       bind(this):\n\t       The wordCloudApi is outing 2 functions and with binding this so it will use 'this' in the functions as the specific scope\n\t       and will not use the parent scope.\n\t       */\n\t      that.wordCloudApi = {\n\t        setText: that.wordService.setText.bind(this),\n\t        setListener: that.wordService.setListener.bind(this),\n\t        onSelect: that.wordService.onSelect.bind(this),\n\t        onHover: that.wordService.onHover.bind(this)\n\t      };\n\t      /* notify parent about onInit\n\t       The validation is to check if there is in the external directive has the init function before we send to it the Api\n\t       the 'config' var will be the external controller .\n\t       */\n\t      if (angular.isDefined(that.config) && angular.isFunction(that.config.initCloud)) {\n\t        that.config.initCloud(that.wordCloudApi);\n\t        that.configUrl = that.config.configUrl;\n\t        that.configParams = that.config.configParams;\n\t      } else console.log(\"no initCloud define in external controller\");\n\t    };\n\t    this.selectedWords = [];\n\t    $element.on(\"$destroy\", function () {\n\t      console.log(\"wordCloud controller destroyed\");\n\t    });\n\t  }\n\n\t  _createClass(WordCloudController, [{\n\t    key: 'defineCloud',\n\t    value: function defineCloud(data) {\n\t      var that = this;\n\n\t      that.elem = that.element[0];\n\n\t      that.w = that.elem.clientWidth; // check if matter using that than $element\n\t      that.h = that.elem.clientHeight;\n\n\t      /*\n\t       * Compute size of the word cloud by the length of the input words:\n\t       * */\n\t      var dataLength = data.length;\n\n\t      var charSum = 0;\n\t      var pixNeeded = 0;\n\n\t      _.forEach(data, function (word) {\n\t        charSum += word.text.length;\n\t        pixNeeded += that.wordService.calcFontSize(word.id) * word.text.length;\n\t      });\n\n\t      that.divideBy = pixNeeded < 7000 ? 3 : pixNeeded < 9000 ? 2 : pixNeeded < 12000 ? 1.7 : pixNeeded < 13000 ? 1.6 : pixNeeded < 15000 ? 1.5 : pixNeeded < 16000 ? 1.4 : pixNeeded < 17000 ? 1.3 : 1;\n\n\t      /*\n\t       * Compute size of the scale by the length of the input words:\n\t       * */\n\t      if (dataLength < 30) {\n\t        that.scale = 1.4;\n\t      } else if (dataLength > 30 && dataLength < 100) {\n\t        that.scale = 1.3;\n\t      } else if (dataLength > 100 && dataLength < 150) {\n\t        that.scale = 1.2;\n\t      } else if (dataLength > 150 && dataLength < 250) {\n\t        that.scale = 0.9;\n\t      } else that.scale = 0.8;\n\n\t      that.colors = [\"#9FA8DA\", \"#7986CB\", \"#5C6BC0\", \"#3F51B5\", \"#3949AB\", \"#303F9F\", \"#283593\", \"#1A237E\"];\n\n\t      that.color = d3.scale.linear().domain([that.wordService.fontMin, that.wordService.fontMax]).range([that.colors[0], that.colors[7]]);\n\t    }\n\t  }, {\n\t    key: 'mouseHovered',\n\t    value: function mouseHovered(d) {\n\t      d3.select('#p' + d.id).classed(\"hovered\", !d.hovered);\n\t      d3.select(this.element[0]).classed(\"hovered-mode\", !d.hovered);\n\t      this.runListeners('onHover', d);\n\t    }\n\t  }, {\n\t    key: 'mouseOut',\n\t    value: function mouseOut(d) {\n\t      d3.select('#p' + d.id).classed(\"hovered\", !d.hovered);\n\t      d3.select(this.element[0]).classed(\"hovered-mode\", !d.hovered);\n\t      this.runListeners('onHover', d);\n\t    }\n\t  }, {\n\t    key: 'clicked',\n\t    value: function clicked(d) {\n\t      if (angular.isDefined(event.stopPropagation)) {\n\t        // for testing\n\t        event.stopPropagation();\n\t        event.preventDefault();\n\t      }\n\t      var that = this.that,\n\t          domWord = this.domWord;\n\t      // CTRL click handling :\n\t      if (window.event.ctrlKey || this.isCtrl) {\n\t        // this.ctrl for testing\n\t        if (d3.select(domWord).classed(\"selected\") /*d.selected*/) {\n\t            _.remove(that.selectedWords, d);\n\t            d3.select(domWord).classed(\"selected\", !d3.select(domWord).classed(\"selected\") /*!d.selected*/);\n\t            d3.select(that.elem).classed(\"selection-mode\", d3.select(domWord).classed(\"selected\") /*!d.selected*/);\n\t            that.runListeners('onSelect', d, []);\n\t          } else {\n\t          that.selectedWords.push(d);\n\t          d3.select(domWord).classed(\"selected\", !d3.select(domWord).classed(\"selected\") /*!d.selected*/);\n\t          d3.select(that.elem).classed(\"selection-mode\", d3.select(domWord).classed(\"selected\") /*!d.selected*/);\n\t          that.runListeners('onSelect', d, that.selectedWords);\n\t        }\n\t      }\n\t      // single click handling :\n\t      else {\n\t          var flag = d3.select(domWord).classed(\"selected\"); // d.selected;\n\t          var selectedFilter = _.filter(that.data, { selected: true }); // TODO: use that.selectedWords\n\t          d3.selectAll('.selected').classed('selected', false);\n\t          _.forEach(selectedFilter, function (word) {\n\t            word.selected = false;\n\t          });\n\t          that.selectedWords.splice(0, that.selectedWords.length);\n\t          that.selectedWords.push(d);\n\t          //d.selected = flag;\n\t          d3.select(domWord).classed(\"selected\", !flag);\n\t          d3.select(that.elem).classed(\"selection-mode\", !flag);\n\t          if (angular.isDefined(that.runListeners)) {\n\t            // for testing\n\t            that.runListeners('onSelect', d, undefined); // undefined array in case of single select\n\t          }\n\t        }\n\t    }\n\t  }, {\n\t    key: 'deselectAll',\n\t    value: function deselectAll() {\n\t      // click outside words cause unselect\n\t      //for each  selected item, unselect it.\n\t      d3.selectAll('.selected').classed('selected', false);\n\t      d3.select(this.elem).classed(\"selection-mode\", false);\n\t      this.runListeners('onSelect', undefined);\n\t    }\n\t  }, {\n\t    key: 'draw',\n\t    value: function draw() {\n\t      var that = this;\n\t      that.cloud.attr(\"transform\", \"translate(\" + that.w / 2 + \",\" + that.h / 2 + \")scale(\" + that.scale + \")\") // re translate\n\t      .selectAll(\"text\").data(that.data).enter().append(\"text\").attr(\"id\", function (d) {\n\t        return \"p\" + d.id;\n\t      }).transition().duration(500).attr(\"text-anchor\", \"middle\").attr(\"transform\", function (d) {\n\t        return \"translate(\" + [d.x, d.y] + \")\";\n\t      }).each(function (d) {\n\t        d3.select(this).on(\"click\", that.clicked.bind({ that: that, domWord: this }));\n\t      }).each(function (d) {\n\t        d3.select(this).on(\"mouseover\", that.mouseHovered.bind(that));\n\t      }).each(function () {\n\t        d3.select(this).on(\"mouseout\", that.mouseOut.bind(that));\n\t      }).attr('opacity', 1).style(\"font-size\", function (d) {\n\t        return d.size + \"px\";\n\t      }).style(\"font-family\", \"'Noto Sans Hebrew', 'roboto'\").style(\"fill\", function (d) {\n\t        return that.color(d.size);\n\t      }).text(function (d, i) {\n\t        return d.text;\n\t      });\n\t    }\n\n\t    /**\n\t     * @description Sets the cloud and the layout\n\t     *              1) Gets data and define dimensions of the cloud by defineCloud\n\t     *              2) remove existing cloud to avoid multiplication of the cloud (in case of inserting new words to existing cloud) (test there is only one cloud in teh div)\n\t     *              3) appends alot of attrs to the cloud (test if all of them exist)\n\t     *              4) appends alot of attrs to the layout (test if all of them exist)\n\t     *              5) dispatching draw() (test if it was dispatched)\n\t     *\n\t     * @param data\n\t     * @returns --\n\t     */\n\n\t  }, {\n\t    key: 'initCloud',\n\t    value: function initCloud(data) {\n\t      this.count++;\n\t      var that = this;\n\t      this.defineCloud(data);\n\t      // When isInitialized -->  remove cloud , otherwise --> append layout to the existing svg and g\n\t      if (this.cloud || this.count) {\n\t        this.cloud = null;\n\t        d3.select(that.elem.childNodes[1]).remove(); // the div of the any wordCloud is has 2 childNodes: #text and SVG . by removing svg we adding it to the same div.\n\t        that.elem = null;\n\t      }\n\t      that.elem = that.element[0];\n\n\t      this.data = data;\n\t      var innerThat = that;\n\n\t      this.cloud = d3.select(that.elem).append(\"svg\").attr(\"viewBox\", \"0 0 \" + that.w + \" \" + that.h + \"\").attr(\"preserveAspectRatio\", \"xMidYMid meet\").on('click', that.deselectAll.bind(that)).append(\"g\").attr(\"transform\", \"translate(\" + that.w / 2 + \",\" + that.h / 2 + \")scale(\" + that.scale + \")\").attr(\"margin\", \"auto\");\n\n\t      this.layout = d3.layout.cloud().size([that.w / that.divideBy, that.h / that.divideBy]).words(that.data).timeInterval(Infinity).padding(2).rotate(function () {\n\t        return 0;\n\t      }).font(\"'Noto Sans Hebrew', 'roboto'\").spiral('rectangular').text(function (d) {\n\t        return d.text;\n\t      }).fontSize(function (d) {\n\t        return innerThat.wordService.calcFontSize(d.id);\n\t      }).on(\"end\", innerThat.draw.bind(innerThat)) // when the layout has finished attempting to place all words an \"end\" event is dispatched\n\t      .start();\n\t    }\n\t  }]);\n\n\t  return WordCloudController;\n\t}();\n\n/***/ }\n/******/ ]);\nangular.module(\"wbxWordCloud\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"app/components/wordCloud/wordCloud.html\",\"<div id=wordCloud class=\\\"word-cloud color\\\" ng-class=\\\"{\\'selection-mode\\': vm.selectionMode,\\'hover-mode\\':vm.hoveredMode}\\\"></div>\");}]);"],"file":"scripts/app-1224f1261c.js","sourceRoot":"/source/"}